
# üßÆ Practical 02 ‚Äì Genome Assembly

## De Novo assembly
We will perform a de novo assembly of the Saccharomyces cerevisiae genome using reads obtained from three different sequencing technologies: Illumina, PacBio, and Nanopore.
To accomplish this, we will use different types of assemblers and compare the resulting assemblies.

### üß† Short-read assembly: ABySS
To assemble the Illumina short reads, we will use ABySS, a de Bruijn graph‚Äìbased assembler.

- **de Bruijn graph assemblers** (e.g., ABySS, SPAdes)  
  These methods break reads into *k*-mers and connect identical *k*-mers to reconstruct the sequence.  
  They are highly efficient for short, accurate reads but often struggle with repetitive regions and variable coverage.

Since our reads are paired-end, we will execute the assembler using the command abyss-pe.
Some program parameters must be specified by the user, and they can have a strong impact on the resulting assembly. The most critical parameter is k, which defines the k-mer size used to construct the graph.

Choosing an appropriate k-mer size is essential: smaller k values tend to produce more contiguous assemblies but may increase misassemblies, whereas larger k values result in more accurate but fragmented assemblies.
Some assemblers, such as SPAdes, automatically test multiple k-mer values to identify the optimal configuration for a given dataset.

In this exercise, we will run ABySS once using a k-mer size of 94, providing the paired-end Illumina reads as input.

#### Input data

The input Illumina reads for this exercise are provided in the folder day1/raw_data under the names:

* SRR8922830_1.fastq

* SRR8922830_2.fastq

Before running the assembly, create a new directory where ABySS will generate its output files.
For example:
```bash
# Create a new folder for the assembly output
mkdir abyss_yeast
cd abyss_yeast
```
&nbsp;

#### ‚öôÔ∏è De novo assembly
We will now run ABySS with paired-end reads and a k-mer size of 94.
To do this, we need to provide the assembler with the chosen k-mer value and the forward and reverse read files.

‚õî The following is the basic command to run abyss-pe:

```bash
# basic command
nohup abyss-pe name=yeast_k94 k=94 in='reads_1.fastq.gz reads_2.fastq.gz'  B=10G

```
Notes

- **name=** defines the prefix for all output files generated by ABySS.
- **k=** specifies the k-mer size used to build the de Bruijn graph.
- **in=** provides the list of paired-end input files separated by a space.
- **B=** enables the Bloom filter mode and defines the amount of memory allocated to the process.
- The main output file will be yeast_k94-contigs.fa, which contains the assembled contigs.

‚ö†Ô∏è **Warning**

Make sure to run the command from within the abyss_yeast directory (or any directory where you want the output files to be stored).
If the reads are not in the same directory, provide the full path to the input files in the in= argument.

### üöÄ Running the De novo assembly in background with nohup

The command nohup (no hang up) can be placed at the beginning of a command line to keep a process running even after closing the terminal session.
In other words, it prevents the process from being terminated when you log out or disconnect from the shell.
This is particularly useful for long-running tasks, such as genome assemblies.
For example:
```bash
nohup abyss-pe name=yeast_k94 k=94 in='/mnt/lab/Data/day1/illumina_reads/SRR8922830_1.fastq /mnt/lab/Data/day1/illumina_reads/SRR8922830_2.fastq' B=10G &

```

* The & at the end runs the process in the background.
* All standard output will be written to a file named nohup.out in the current directory (unless redirected).


---

## Long-read assembly


Long-read assemblers are typically based on **OLC (Overlap‚ÄìLayout‚ÄìConsensus)** algorithms.  
Unlike *de Bruijn* graph assemblers, which break reads into *k*-mers, OLC-based methods first identify overlaps between long reads, then build a layout graph, and finally generate a consensus sequence.  
This approach is well suited for long, noisy reads obtained from **PacBio** or **Nanopore** sequencing, as it can span repetitive regions that are often unresolved in short-read assemblies.

---

### Input data

The long-read datasets for this exercise are provided in the folder `day1/raw_data/longreads` under the name:

- `SRR5989372.fastq`

---

### Assembly with Canu

‚õî  We will not run Canu during this session because it requires significant computational resources and can take several hours to complete.



**Canu** is an assembler based on the OLC algorithm.  
It allows the user to specify the read type using the options:

- `-pacbio-raw` for raw PacBio reads  
- `-nanopore-raw` for raw Nanopore reads  
- or both, if assembling a mixed dataset.

Canu can take either *raw* or *corrected* reads as input.  
The expected genome size must be provided (for *Saccharomyces cerevisiae*, approximately **12 Mb**).  
Because Canu does not rely on quality scores, both **FASTA** and **FASTQ** input formats are accepted.

‚õî Example command:

```bash
canu -p yeast -d canu_yeast genomeSize=12m -nanopore-raw ../raw_data/longreads/SRR5989372.fastq
```
---

### üöÄ Assembly with Flye

Flye is another long-read assembler that is considerably faster than Canu.
Unlike Canu, it does not perform read correction prior to assembly, which makes it more efficient for quick analyses.
Flye allows specifying the type of long reads using the options:

* pacbio-raw for PacBio reads

* nano-raw for Nanopore reads

* or the corrected equivalents (--pacbio-corr, --nano-corr).

Run the program using the provided Nanopore reads:

```bash
flye --nano-raw ../raw_data/longreads/SRR5989372.fastq --genome-size 12m --out-dir flye_yeast
```
üìå Note: Flye will automatically create a directory (flye_yeast) to store intermediate files and the final assembly (assembly.fasta).
This process may take several minutes depending on the computational resources available.


